<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Interactive Project</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #61443e;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				background-color: #aaccff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				color: #ffffff;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}
			a {
				color: yellow;
			}
			#oldie {
				background:rgb(0,0,50) !important;
				color:#fff !important;
			}

		</style>
	</head>
	<body>

	
		<div id="container"></div>

		<script src="build/three.js"></script>
		<script src="build/three.min.js"></script>

		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/controls/DeviceOrientationControls.js"></script>


		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src='js/libs/dat.gui.min.js'></script>
		<script src="./js/GPUParticleSystem.js"></script>
		<script src="js/Player.js"></script>

		<script src="js/loaders/STLLoader.js"></script>
		<script src="js/loaders/OBJLoader.js"></script>
		<script src="Common/MV.js"></script>
		<script src="js/math.js"></script>

		<script>

			if ( ! Detector.webgl ) {
				Detector.addGetWebGLMessage();
				document.getElementById( 'container' ).innerHTML = "";
			}
			var container, stats;
			var camera, controls, scene, renderer;
			var mesh, texture, geometry, material;
			var worldWidth = 128, worldDepth = 128,
			worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;
			//var cubeCamera;
			var sphereControls;
			//var loader;
			//var mesh2= new THREE.Mesh();

			var planeWidth = 20000;
			var planeHeight = 20000;

			var firstPlayerControls = {
				moveLeft: false,
				moveRight: false,
				leftClicked: 0,
				rightClicked: 0,
				color: 0xff3399
			};
			var secondPlayerControls = {
				moveLeft: false,
				moveRight: false,
				leftClicked: 0,
				rightClicked: 0,
				color: 0x0bdd43
			};

			var thirdPlayerControls = {
				moveLeft: false,
				moveRight: false,
				leftClicked: 0,
				rightClicked: 0,
				color: 0x0033cc
			};
			var fourthPlayerControls = {
				moveLeft: false,
				moveRight: false,
				leftClicked: 0,
				rightClicked: 0,
				color: 0xfff316
			};
			
			playersControl = [firstPlayerControls, secondPlayerControls, thirdPlayerControls, fourthPlayerControls];
			players = [];
			nPlayer = 4;

			var clock = new THREE.Clock();
			var gui, shadowCameraHelper, shadowConfig = {
				shadowCameraVisible: false,
				shadowCameraNear: 750,
				shadowCameraFar: 4000,
				shadowCameraFov: 30,
				shadowBias: -0.0002
			};

			var direction = 1; //0=left 1=front 2=right
			var tick=0;
			var click=0;
			/*var particleOptions = {
				position: new THREE.Vector3(),
				//positionRandomness: .3,
				velocity: new THREE.Vector3(),
				//velocityRandomness: .5,
				color: 0xff0040,
				//colorRandomness: .2,
				//turbulence: .5,
				//lifetime: 2,
				size: 50,
				//sizeRandomness: 1
			};
			var particleSpawnerOptions = {
				spawnRate: 1500000,
				horizontalSpeed: 1.5,
				verticalSpeed: 1.33,
				timeScale: 1
			};*/

			init();
			animate();
			function init() {
				container = document.getElementById( 'container' );

			//KEYBOARD CONTROLS
				var onKeyDown = function ( event ) {
					switch ( event.keyCode ) {
						case 81: // a
							firstPlayerControls.moveLeft = true;
							firstPlayerControls.leftClicked++;
							break;
						case 87: // d
							firstPlayerControls.moveRight = true;
							firstPlayerControls.rightClicked++;
							break;

						case 104: // a
							secondPlayerControls.moveLeft = true;
							secondPlayerControls.leftClicked++;
							break;
						case 105: // d
							secondPlayerControls.moveRight = true;
							secondPlayerControls.rightClicked++;
							break;
						
						case 67: // a
							thirdPlayerControls.moveLeft = true;
							thirdPlayerControls.leftClicked++;
							break;
						case 86: // d
							thirdPlayerControls.moveRight = true;
							thirdPlayerControls.rightClicked++;
							break;
													
						case 190: // a
							fourthPlayerControls.moveLeft = true;
							fourthPlayerControls.leftClicked++;
							break;
						case 173: // d
							fourthPlayerControls.moveRight = true;
							fourthPlayerControls.rightClicked++;
							break;
					}
				};
				var onKeyUp = function ( event ) {
					switch( event.keyCode ) {
						case 81: // a
							firstPlayerControls.moveLeft = false;
							firstPlayerControls.leftClicked = 0;
							break;
						case 87: // d
							firstPlayerControls.moveRight = false;
							firstPlayerControls.rightClicked = 0;
							break;

						case 104: // a
							secondPlayerControls.moveLeft = false;
							secondPlayerControls.leftClicked = 0;
							break;
						case 105: // d
							secondPlayerControls.moveRight = false;
							secondPlayerControls.rightClicked = 0;
							break;
						
						case 67: // a
							thirdPlayerControls.moveLeft = false;
							thirdPlayerControls.leftClicked = 0;
							break;
						case 86: // d
							thirdPlayerControls.moveRight = false;
							thirdPlayerControls.rightClicked = 0;
							break;
													
						case 190: // a
							fourthPlayerControls.moveLeft = false;
							fourthPlayerControls.leftClicked = 0;
							break;
						case 173: // d
							fourthPlayerControls.moveRight = false;
							fourthPlayerControls.rightClicked = 0;
							break;
					}
				};




			//CAMERA SETTINGS
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 45, 20000 );
				
				camera.position.x = 10;
				camera.position.y = 10000;
				camera.position.z = 10;

				//camera.rotateY(  - Math.PI / 4 );
				//camera.lookAt( scene.position )camera.rotate.y = 90 * Math.PI / 180
				//camera.position.z = 100;




			
				document.addEventListener( 'keydown', onKeyDown, false );
				document.addEventListener( 'keyup', onKeyUp, false );


				renderer = new THREE.WebGLRenderer({antialias:true});
				//renderer.setClearColor( 0xaaccff );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				//controls = new THREE.FirstPersonControls( camera );
				controls = new THREE.OrbitControls( camera, renderer.domElement );

				scene = new THREE.Scene();
		/*	//PARTICLE
				particleSystem = new THREE.GPUParticleSystem( {
					maxParticles: 250000
				} );
				scene.add( particleSystem );*/
	
				//scene.fog = new THREE.FogExp2( 0xaaccff, 0.0007 );
				//scene.fog = new THREE.Fog( 0, 1000, 10000 );
				


	/*			var planeGeometry = new THREE.PlaneBufferGeometry( 100, 100 );
				var ground = new THREE.Mesh( planeGeometry, groundMaterial );
				ground.position.set( 0, 0, 0 );
				ground.rotation.x = - Math.PI / 2;
				ground.scale.set( 1000, 1000, 1000 );
				ground.receiveShadow = true;
				scene.add( ground );*/


				geometry = new THREE.PlaneGeometry( planeWidth, planeHeight, worldWidth - 1, worldDepth - 1 );
				geometry.rotateX( - Math.PI / 2 );
				//geometry.rotateY( - Math.PI / 4 );

				var texture = new THREE.TextureLoader().load( "textures/Tron_Background1024.jpg" );
				//var texture = new THREE.TextureLoader().load( "textures/patterns/bright_squares256.png" );
				texture.repeat.set( 5, 5 );
				texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				texture.magFilter = THREE.NearestFilter;
				texture.format = THREE.RGBFormat;

				// GROUND
				var groundMaterial = new THREE.MeshPhongMaterial( {
					shininess: 80,
					color: 0xffffff,
					specular: 0xffffff,
					map: texture
				} );

				material = new THREE.MeshBasicMaterial( { color: 0xffffff, map: texture } ); 
				mesh = new THREE.Mesh( geometry, groundMaterial );
				mesh.receiveShadow = true;

				scene.add( mesh );




		   // LIGHTS
		    scene.add(new THREE.AmbientLight(0xffffff,2));

		  /*  var light;

		    light = new THREE.DirectionalLight(0xdfebff, 1.75);
		    light.position.set(300, 400, 50);
		    light.position.multiplyScalar(1.3);

		    light.castShadow = true;
		    light.shadowCameraVisible = true;

		    light.shadowMapWidth = 512;
		    light.shadowMapHeight = 512;

		    var d = 200;

		    light.shadowCameraLeft = -d;
		    light.shadowCameraRight = d;
		    light.shadowCameraTop = d;
		    light.shadowCameraBottom = -d;

		    light.shadowCameraFar = 1000;
		    light.shadowDarkness = 0.2;

		    scene.add(light);*/

				/*var spotLight = new THREE.SpotLight( 0xffffff );
				spotLight.position.set( 100, 1000, 100 );

				spotLight.castShadow = true;

				spotLight.shadow.mapSize.width = 1024;
				spotLight.shadow.mapSize.height = 1024;

				spotLight.shadow.camera.near = 500;
				spotLight.shadow.camera.far = 4000;
				spotLight.shadow.camera.fov = 30;

				scene.add( spotLight );
*/






		/*	//SFERA COLORATA	
				var littleSphere = new THREE.SphereGeometry( 10, 64, 64 );
				light1 = new THREE.PointLight( 0xff0040, 2, 5000 );
				light1.position.x = 100;
				light1.position.y = 100;
				light1.position.z = 100;
				light1.add( new THREE.Mesh( littleSphere, new THREE.MeshBasicMaterial( { color: 0xff0040 } ) ) );
				scene.add( light1 );
*/

			//SFERA RIFLETTENTE
	/*			cubeCamera = new THREE.CubeCamera( 1, 10000, 128 );
				scene.add(cubeCamera);
				var mirrorMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: cubeCamera.renderTarget } );
				//var mirrorMaterial = new THREE.MeshPhongMaterial( { emissive: 0xffffff, envMap: cubeCamera.renderTarget } );

				sphere = new THREE.Mesh( new THREE.IcosahedronBufferGeometry( 100, 3 ), mirrorMaterial );

				sphere.position.y=100;
				sphere.receiveShadow = true;

				scene.add( sphere );
*/			
				for (var i = 0; i < nPlayer; i++)
					players[i] = new THREE.Player( playersControl[i],planeWidth, planeHeight, i);
				
				
				//sphereControls = new THREE.DeviceOrientationControls(sphere);



		/*		cubeCamera = new THREE.CubeCamera( 1, 10000, 128 );
				scene.add(cubeCamera);
				var mirrorMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: cubeCamera.renderTarget } );

				loader = new THREE.STLLoader();
				loader.load( 'stl/SWTOR_Spy.stl', function ( geometry ) {
					var mesh = new THREE.Mesh( geometry, mirrorMaterial );
					mesh.position.set( 1000, 0, 100);
					mesh.rotation.set( - Math.PI / 2, 0, 0 );
					mesh.scale.set( 2,2,2 );
					mesh.castShadow = true;
					mesh.receiveShadow = true;
					mesh2=mesh;
					scene.add( mesh );
				}  );*/





			/*	var loader2 = new THREE.OBJLoader(  );

					loader.load( 'stl/LIGHT_BIKE_03.obj', function ( geometry ) {
					mesh = new THREE.Mesh( geometry, mirrorMaterial2 );
					mesh.position.set( 100, 0, 100);
					mesh.rotation.set( - Math.PI / 2, 0, 0 );
					mesh.scale.set( 0.1,0.1,0.1 );
					mesh.castShadow = true;
					mesh.receiveShadow = true;
					scene.add( mesh );
				} );*/
				/*
				pointLight = new THREE.PointLight( 0xff0000, 10, 5000 );
				pointLight.position.set( sphere.position.x, 100, sphere.position.z );
				scene.add( pointLight );*/


				/*// SHADOW CAMERA HELPER

				shadowCameraHelper = new THREE.CameraHelper( sunLight.shadow.camera );
				shadowCameraHelper.visible = shadowConfig.shadowCameraVisible;
				scene.add( shadowCameraHelper );*/
				//******renderer******
				container.innerHTML = "";
				container.appendChild( renderer.domElement );
				stats = new Stats();
				container.appendChild( stats.dom );
				//
				window.addEventListener( 'resize', onWindowResize, false );


/*
				gui = new dat.GUI( { width: 400 } );
				// SHADOW
				var shadowGUI = gui.addFolder( "Shadow" );
    		shadowGUI.add( shadowConfig, 'shadowCameraVisible' ).onChange( function() {
					shadowCameraHelper.visible = shadowConfig.shadowCameraVisible;
				});
				shadowGUI.add( shadowConfig, 'shadowCameraNear', 1, 1500 ).onChange( function() {
					sunLight.shadow.camera.near = shadowConfig.shadowCameraNear;
					sunLight.shadow.camera.updateProjectionMatrix();
					shadowCameraHelper.update();
				});
				shadowGUI.add( shadowConfig, 'shadowCameraFar', 1501, 5000 ).onChange( function() {
					sunLight.shadow.camera.far = shadowConfig.shadowCameraFar;
					sunLight.shadow.camera.updateProjectionMatrix();
					shadowCameraHelper.update();
				});
				shadowGUI.add( shadowConfig, 'shadowCameraFov', 1, 120 ).onChange( function() {
					sunLight.shadow.camera.fov = shadowConfig.shadowCameraFov;
					sunLight.shadow.camera.updateProjectionMatrix();
					shadowCameraHelper.update();
				});
				shadowGUI.add( shadowConfig, 'shadowBias', -0.01, 0.01 ).onChange( function() {
					sunLight.shadow.bias = shadowConfig.shadowBias;
				});
				shadowGUI.open();*/

			}

				
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			
			function animate() {
				requestAnimationFrame( animate );
			/*	if ( firstPlayerControls.moveForward ) 	direction = 1;//sphere.position.z-=10;
				else if ( firstPlayerControls.moveLeft ) direction = 0;//sphere.position.x-=10;
				else if ( firstPlayerControls.moveRight ) direction = 2;//sphere.position.x+=10;


				switch ( direction ) {
						case 0: // left
							sphere.position.z-=10; break;
						case 1: // front
							sphere.position.x-=10; break;
						case 2: // right
							sphere.position.x+=10; break;
					}*/

				for (var i = 0; i < nPlayer; i++) {
					players[i].updatePlayerModel(playersControl[i], scene);

					//players[i].circleRender(scene,playersControl[i]);
				}


	/*			options.position.x = sphere.position.x;
				options.position.y = sphere.position.y;
				options.position.z = sphere.position.z;*/

				//var delta = clock.getDelta() ;
				//tick += delta;
				//if ( tick < 0 ) tick = 0;
				//if ( delta > 0 ) {
				/*	particleOptions.position.x = first.sphere.position.x;
					particleOptions.position.y = 0;
					particleOptions.position.z = first.sphere.position.z;
					for ( var x = 0; x < particleSpawnerOptions.spawnRate * delta; x++ ) {
						// Yep, that's really it.	Spawning particles is super cheap, and once you spawn them, the rest of
						// their lifecycle is handled entirely on the GPU, driven by a time uniform updated below
						particleSystem.spawnParticle( particleOptions );
					}
				//}
				particleSystem.update( tick );
*/

				render();
				stats.update();
			}
			function render() {



				var delta = clock.getDelta();
					//time = clock.getElapsedTime() * 10;

				//mesh.geometry.verticesNeedUpdate = true;
				controls.update( delta );
				//sphereControls.update( delta );
			// render cube map

				//for (var i = 0; i < nPlayer; i++) 
					//players[i].cubeRender(renderer, scene);

			/*	mesh2.visible = false;
				cubeCamera.position.copy( mesh2.position );
				cubeCamera.updateCubeMap( renderer, scene );
				mesh2.visible = true;*/
/*
				sphere.visible = false;
				cubeCamera.position.copy( sphere.position );
				cubeCamera.updateCubeMap( renderer, scene );
				sphere.visible = true;
*/

			// render scene
				renderer.render( scene, camera );
			}
		</script>

	</body>
</html>
